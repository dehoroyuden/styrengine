--- Vulkan API Notebook ---
Step 1 - Instance and physical device selection
- VkInstance
- VkPhysicalDevice

Step 2 - Logical device and queue families
- VkDevice (logical device)
- VkPhysicalDeviceFeatures
- VkQueue

Step 3 - Window surface and swap chain
- VkSurfaceKHR
- VkSwapChainKHR
(..KHR postfix meant that this are Vulkan extensions)
_Swapchain_ is a collection of render targets. Its basic purpouse is to ensure that the image that we're currently
rendering to is different from the one that is currently on the screen. This is IMPORTANT to ensure, that only 
complete images are shown.

Step 4 - Image views and framebuffers
- VkImageView
- VkFramebuffer

Step 5 - Render passes
Describe the type of images that are used during rendering operations
- VkFramebuffer

Step 6 - Graphics pipeline
- VkPipeline
- VkShaderModule

Step 7 - Command pools and command buffers
- VkCommandBuffer
- VkCommandPool
To draw simple triangle we need to record a command buffer with the following operations:
	- Begin the render pass
	- Bind the graphics pipeline
	- Draw 3 vertices
	- End the render pass

Step 8 - Main Loop
- vkAcquireNextImageKHR
- vkQueueSubmit
- vkQueuePresent


IMAGE VIEWS
An image view is quite literaly a view into an image. It describes how to access the image
and which part of the image to access, for example if it should be treated as a 2D Texture depth
texture without any mipmaping levels.

--- Graphics pipeline basics ---

1. INPUT ASSEMBLER - collects the raw vertex data from the buffer you specify and may also use an
index buffer to repeat certain elements without having to duplicate the vertex data itself.

2. VERTEX SHADER - Is run for every vertex  and generally applies transformations to turn vertex position
from model space to screen space. It also passes per-vertex data down pipeline.

3. TESSELATION SHADERS - allow you to subdivide geometry based on certain rules to increasse the mesh quality.
This is often used to make surfaces like brick walls and sraircases look less flat when they nearby.

4. GEOMETRY SHADER - is run on every primitive (triangle, line, point) and can discard it or output more
primitives than came in. This is similar to tesselation shader, but much more flexible. However,
it is not used much in today's applications because the performance is not that good on most
graphics cards except for Intel's integrated GPUs.

5. RASTERIZATION - stage discretizes the primitives into _fragmetns_. These are the pixel elements that
they fill in the framebuffer. Any fragments that fall outside the screen are discarded and the 
attributes outputted by the vertex shader are interpolated across the fragments, as shown
in the figure. Usually the fragments that are behind other primitive fragments are also discarded here
because of depth testing.

6. FRAGMENT SHADER - is invoked for every fragment that survives and determines which framebuffer(s)
the fragments are written to and which color and depth valuse. It can do this using the interpolated
data from the vertex shader, which can include things like texture coordinates and normals for lighting.


--- Vertex Shader ---
The vertex shader process each incoming vertex. It takes its attributes, like world position, color,
normal and texture coordinates as input. The output is the final position in clip coordinates and the
attributes that need to be passed on the fragment shader, like color and texture coordinates. These 
values will then be interpolated over the fragments by the rasterizer to produce a smooth gradient.

A _clip coordinate_ is a four dimentional vector from the vertex shader that is subsiquently turned
into a _normalized device coordinate_ by dividing the whole vector by its last component.

-- Rendering and Presentation --

At a high level, rendering a frame in Vulkan consists of a common set of steps:
- Wait for the previous frame to finish
- Acquire an image from the swap chain
- Record a command buffer which draws the scene onto that image
- Submit the recorded command buffer
- Present the swap chain image

-- Vertex Buffers --
The vertex buffer we have right now works correctly, but the memory type that allows us to access it from
the CPU might not be the most optimal memory type for the graphics card itself to read from. The
most optimal memory has VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT flag and is usually not accessible by the CPU
on dedicated graphics cards. We're going to create two vertex buffers. One _staging buffer_ in CPU accessible
memory to upload the data from the vertex array to, and the final vertex buffer in device local memory.
We'll then use a buffer copy command to move the data from the staging buffer to the actual vertex buffer.

- Transfer queue -
The buffer copy command requires a queue family that supports transfer operations, which is indicated
using VK_QUEUE_TRANSFER_BIT. The good news is that any queue family with VK_QUEUE_GRAPHICS_BIT or
VK_QUEUE_COMPUTE_BIT capabilities already implicitly support VK_QUEUE_TRANSFER_BIT operations.
The implementation is not required to explicitly list it in queueFlags in those cases.

If you like a challange, than you can still try to use a different queue family specifically for transfer
operations. It will require you to make the following modifications to your program:
 - Modify _QueueFamilyIndices_ and function _FindQueueFamilies_ to explicitly look for a queue family with
the _ VK_QUEUE_TRANSFER_BIT _ bit, but not the _ VK_QUEUE_GRAPHICS_BIT _ 
 - Modify _CreateLogicalDevice_ to request a handle to the transfer queue
 - Create a second command pool for command buffers that are submitted on the transfer queue family
 - Change tje _sharingMode_ of resources to be VK_SHARING_MODE_CONCURRENT and specify both the graphics
and transfer queue families
 - Submit any transfer commands like vkCmdCopyBuffer (which we'll be using in this chapter) to
transfer queue instead of the graphics queue

-- Mip Mapping --
- Sampler -
While the VkImage holds the mipmap data, VkSampler controls how that data is read while rendering.
Vulkan allows you to specify minLod, maxLod, mipLodBias, mipmapMode. When a texure is sampled,
the sampler selects a mip level according to the following pseudocode:

	lod = getLodLevelFromScreenSize();
	lod = clamp(lod + mipLodBias, minLod, maxLod);
	
	level = clamp(floor(lod), 0, texture.mipLevels - 1) // Clamped to the number of levels in texture

	if(mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST)
	{
		color = sample(level)
	}
	else
	{
		color = blend(sample(level), sample(level + 1))
	}